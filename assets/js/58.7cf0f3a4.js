(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{339:function(e,a,t){"use strict";t.r(a);var r=t(14),s=Object(r.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:""}},[a("a",{staticClass:"header-anchor",attrs:{href:"#"}},[e._v("#")]),e._v(" /")]),e._v(" "),a("h4",{attrs:{id:"消息存储整体架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息存储整体架构"}},[e._v("#")]),e._v(" 消息存储整体架构")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://jiq-picture.yuxing138.top/bb3617813971a0b4537511dd842b0ac8/1702501281818-1546fcea-8ea2-4553-899c-6dce6332f291.png#averageHue=%23f5f3f3&clientId=u9b0552b9-31d0-4&from=paste&height=392&id=u6a8a325b&originHeight=979&originWidth=1830&originalType=binary&ratio=2.5&rotation=0&showTitle=false&size=200043&status=done&style=none&taskId=u185b703f-c2b7-46ee-a14e-6ff2747266a&title=&width=732",alt:"image.png"}})]),e._v(" "),a("h5",{attrs:{id:"commitlog"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#commitlog"}},[e._v("#")]),e._v(" CommitLog")]),e._v(" "),a("p",[e._v("CommitLog是消息存储文件，所有消息都存储在CommitLog文件中。"),a("br"),e._v("消息内容不是定长的。"),a("br"),e._v("CommitLog单个文件大小默认1G。"),a("br"),e._v("消息顺序写入CommitLog文件，当文件满了，写入下一个文件。"),a("br"),e._v("文件名长度20，文件名为起始偏移量。比如"),a("br"),e._v("第一个文件名为00000000000000000000，起始偏移量为0，文件大小为1G=1073741824；"),a("br"),e._v("第二个文件名为00000000001073741824，起始偏移量为1073741824，以此类推。")]),e._v(" "),a("blockquote",[a("p",[e._v("注意：RocketMQ的全部消息都存放在CommitLog文件中。")])]),e._v(" "),a("h5",{attrs:{id:"consumequeue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#consumequeue"}},[e._v("#")]),e._v(" ConsumeQueue")]),e._v(" "),a("p",[e._v("ConsumeQueue是消费队列中的消息的索引，保存指定Topic下的‘某个队列’的消息的位置offset。"),a("br"),e._v("ConsumeQueue文件夹的组织方式：/{topic}/{queueId}/{fileName}。"),a("br"),e._v("ConsumeQueue文件采用定长设计，每一个条目共20字节，8字节的CommitLog物理偏移量、4字节的消息长度、8字节的标签哈希码。"),a("br"),e._v("单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M。")]),e._v(" "),a("blockquote",[a("p",[e._v("注意：消费者是从对应的‘消费队列文件’中读取消息，并不直接从CommitLog中读取消息。")])]),e._v(" "),a("h5",{attrs:{id:"indexfile"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#indexfile"}},[e._v("#")]),e._v(" IndexFile")]),e._v(" "),a("p",[e._v("IndexFile是消息的索引，保存消息标签tag关联的消息的位置offset。"),a("br"),e._v("IndexFile的存储位置是：/index/{fileName}，文件名是创建时间戳，IndexFile大小是固定的约400M，一个IndexFile可以保存 2000W个索引。"),a("br"),e._v("IndexFile的存储设计是：HashMap<key=tag, value=offset>。")]),e._v(" "),a("blockquote",[a("p",[e._v("注意：消息标签的命名不要重复，否则会造成哈希冲突。")])]),e._v(" "),a("h4",{attrs:{id:"页缓存与内存映射"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#页缓存与内存映射"}},[e._v("#")]),e._v(" 页缓存与内存映射")]),e._v(" "),a("h5",{attrs:{id:"文件系统缓存pagecache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文件系统缓存pagecache"}},[e._v("#")]),e._v(" 文件系统缓存PageCache")]),e._v(" "),a("p",[e._v("页缓存（PageCache）是OS对文件的缓存，用于加速对文件的读写。一般来说，程序对文件进行顺序读写的速度几乎接近于内存的读写速度，主要原因就是由于OS使用PageCache机制对读写访问操作进行了性能优化，将一部分的内存用作PageCache。对于数据的写入，OS会先写入至Cache内，随后通过异步的方式由pdflush内核线程将Cache内的数据刷盘至物理磁盘上。对于数据的读取，如果一次读取文件时出现未命中PageCache的情况，OS从物理磁盘上访问读取文件的同时，会顺序对其他相邻块的数据文件进行预读取。")]),e._v(" "),a("blockquote",[a("p",[e._v("注意：由于OS的PageCache机制，程序对文件进行"),a("code",[e._v("顺序读写")]),e._v("的速度几乎接近于内存的读写速度。")])]),e._v(" "),a("p",[e._v("在RocketMQ中，ConsumeQueue逻辑消费队列存储的数据较少，并且是顺序读取，在PageCache机制的预读取作用下，ConsumeQueue文件的读性能几乎接近读内存，即使在有消息堆积情况下也不会影响性能。而对于CommitLog消息存储的日志数据文件来说，读取消息内容时候会产生较多的随机访问读取，严重影响性能。如果选择合适的系统IO调度算法，比如设置调度算法为“Deadline”（此时块存储采用SSD的话），随机读的性能也会有所提升。")]),e._v(" "),a("blockquote",[a("p",[e._v("注意：消息者是从"),a("code",[e._v("ConsumeQueue文件")]),e._v("中读取消息，读性能几乎接近读内存。")])]),e._v(" "),a("h5",{attrs:{id:"内存映射mmap"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存映射mmap"}},[e._v("#")]),e._v(" 内存映射mmap")]),e._v(" "),a("p",[e._v("另外，RocketMQ主要通过MappedByteBuffer对文件进行读写操作。其中，利用了NIO中的FileChannel模型将磁盘上的物理文件直接映射到用户态的内存地址中（这种mmap的方式减少了传统IO将磁盘文件数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销），将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率（正因为需要使用内存映射机制，故RocketMQ的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存）。")]),e._v(" "),a("blockquote",[a("p",[e._v("注意：读取消息内容是随机读取，通过mmap技术将对文件操作转化为对内存操作，提高文件的读写效率。")])]),e._v(" "),a("h4",{attrs:{id:"消息刷盘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#消息刷盘"}},[e._v("#")]),e._v(" 消息刷盘")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://jiq-picture.yuxing138.top/bb3617813971a0b4537511dd842b0ac8/1702507389784-3729e965-860e-4705-8eb4-60f868565d73.png#averageHue=%23eeeded&clientId=u8e5734b0-1db8-4&from=paste&height=448&id=u63b6b178&originHeight=1119&originWidth=920&originalType=binary&ratio=2.5&rotation=0&showTitle=false&size=136397&status=done&style=none&taskId=u1e94eaa5-0947-4491-ba03-6e5eae4f41e&title=&width=368",alt:"image.png"}})]),e._v(" "),a("h5",{attrs:{id:"同步刷盘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同步刷盘"}},[e._v("#")]),e._v(" 同步刷盘：")]),e._v(" "),a("p",[e._v("如上图所示，只有在消息真正持久化至磁盘后RocketMQ的Broker端才会真正返回给Producer端一个成功的ACK响应。同步刷盘对MQ消息可靠性来说是一种不错的保障，但是性能上会有较大影响，一般适用于金融业务应用该模式较多。")]),e._v(" "),a("h5",{attrs:{id:"异步刷盘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#异步刷盘"}},[e._v("#")]),e._v(" 异步刷盘：")]),e._v(" "),a("p",[e._v("能够充分利用OS的PageCache的优势，只要消息写入PageCache即可将成功的ACK返回给Producer端。消息刷盘采用后台异步线程提交的方式进行，降低了读写延迟，提高了MQ的性能和吞吐量。")])])}),[],!1,null,null,null);a.default=s.exports}}]);