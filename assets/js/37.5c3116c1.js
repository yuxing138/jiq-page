(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{317:function(e,r,t){"use strict";t.r(r);var a=t(14),s=Object(a.a)({},(function(){var e=this,r=e._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:""}},[r("a",{staticClass:"header-anchor",attrs:{href:"#"}},[e._v("#")]),e._v(" /")]),e._v(" "),r("h4",{attrs:{id:"一些术语"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一些术语"}},[e._v("#")]),e._v(" 一些术语")]),e._v(" "),r("h5",{attrs:{id:"循环、遍历、迭代"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#循环、遍历、迭代"}},[e._v("#")]),e._v(" 循环、遍历、迭代")]),e._v(" "),r("p",[r("code",[e._v("循环while/for")]),e._v("指重复执行一段代码。（递归、遍历、迭代都是循环。）"),r("br"),r("code",[e._v("遍历for/foreach")]),e._v("指重复执行一段代码来访问集合的每个元素。"),r("br"),r("code",[e._v("迭代iterate")]),e._v("指重复执行"),r("code",[e._v("迭代器iterator.下代next")]),e._v("来访问集合的每个元素。"),r("code",[e._v("迭代器iterator")]),e._v("规定实现"),r("code",[e._v("下代next")]),e._v("，无规定实现"),r("code",[e._v("游标cursor")]),e._v("、"),r("code",[e._v("索引index")]),e._v("。")]),e._v(" "),r("h4",{attrs:{id:"链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[e._v("#")]),e._v(" 链表")]),e._v(" "),r("h5",{attrs:{id:"环形链表q141简单"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#环形链表q141简单"}},[e._v("#")]),e._v(" 环形链表q141简单")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/linked-list-cycle/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("141. 环形链表 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：判断链表是否存在环。"),r("br"),e._v("题解要点："),r("br"),e._v("1、遍历链表，某个节点重复出现说明存在环。"),r("br"),e._v("2、通过哈希表判断是否重复出现。")]),e._v(" "),r("h5",{attrs:{id:"两数相加q2中等"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#两数相加q2中等"}},[e._v("#")]),e._v(" 两数相加q2中等")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/add-two-numbers/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("2. 两数相加 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干："),r("code",[e._v("两个链表的节点值")]),e._v("相加为一个新链表。"),r("br"),e._v("题解要点："),r("br"),e._v("1、同时遍历两个链表，节点值相加放入新链表。"),r("br"),e._v("2、两个"),r("code",[e._v("个位数")]),e._v("相加可能是一个"),r("code",[e._v("十位数")]),e._v("，个位放在当前节点、十位放在下一节点。")]),e._v(" "),r("h5",{attrs:{id:"合并两个有序链表q21简单"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#合并两个有序链表q21简单"}},[e._v("#")]),e._v(" 合并两个有序链表q21简单")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/merge-two-sorted-lists/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("21. 合并两个有序链表 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：将两个升序链表合并为一个新的升序链表。"),r("br"),e._v("题解要点："),r("br"),e._v("1、同时遍历两个链表，比较节点值，先放入小值再放入大值。")]),e._v(" "),r("h5",{attrs:{id:"随机链表的复制q138中等"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#随机链表的复制q138中等"}},[e._v("#")]),e._v(" 随机链表的复制q138中等")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/copy-list-with-random-pointer/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("138. 随机链表的复制 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：深拷贝复制链表。"),r("br"),e._v("题解要点："),r("br"),e._v("1、通过next直接遍历链表。直接拷贝val，放到哈希表中。"),r("br"),e._v("2、继续，通过next直接遍历链表。处理node.next，直接在哈希表中查找node.next，即可知道新节点的node.next是哪个。"),r("br"),e._v("3、继续，通过next直接遍历链表。处理node.random，直接在哈希表中查找node.random，即可知道新节点的node.random是哪个。")]),e._v(" "),r("h5",{attrs:{id:"反转链表iiq92中等"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#反转链表iiq92中等"}},[e._v("#")]),e._v(" 反转链表IIq92中等")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/reverse-linked-list-ii/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("92. 反转链表 II - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：链表反转。"),r("br"),e._v("题解要点："),r("br"),e._v("1、子链表的前置节点（也称虚拟头节点）。"),r("br"),e._v("2、链表反转函数。")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("//反转链表\nprivate void reverseLinkedList(ListNode head) {\n    ListNode pre = null;\n    ListNode cur = head;\n\n    while (cur != null) {\n        ListNode next = cur.next;\n        cur.next = pre;\n        pre = cur;\n        cur = next;\n    }\n}\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br"),r("span",{staticClass:"line-number"},[e._v("10")]),r("br"),r("span",{staticClass:"line-number"},[e._v("11")]),r("br"),r("span",{staticClass:"line-number"},[e._v("12")]),r("br")])]),r("h5",{attrs:{id:"k个一组翻转链表q25困难"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#k个一组翻转链表q25困难"}},[e._v("#")]),e._v(" K个一组翻转链表q25困难")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/reverse-nodes-in-k-group/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("25. K 个一组翻转链表 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：链表反转。"),r("br"),e._v("题解要点："),r("br"),e._v("1、子链表的前置节点（也称虚拟头节点）。"),r("br"),e._v("2、链表反转函数。")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("//链表的翻转，主要依赖这个翻转函数。\n//反转链表，返回头尾节点\npublic ListNode[] myReverse(ListNode head, ListNode tail) {\n    ListNode pre = null;//缓存pre//tail.next;\n    ListNode cur = head;\n    //while (cur != null) {\n    while (pre != tail) {\n        ListNode next = cur.next;//缓存next\n        cur.next = pre;//head.next指向pre（反转）\n        pre = cur;\n        cur = next;//处理下一节点\n    }\n    return new ListNode[]{tail, head};\n}\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br"),r("span",{staticClass:"line-number"},[e._v("8")]),r("br"),r("span",{staticClass:"line-number"},[e._v("9")]),r("br"),r("span",{staticClass:"line-number"},[e._v("10")]),r("br"),r("span",{staticClass:"line-number"},[e._v("11")]),r("br"),r("span",{staticClass:"line-number"},[e._v("12")]),r("br"),r("span",{staticClass:"line-number"},[e._v("13")]),r("br"),r("span",{staticClass:"line-number"},[e._v("14")]),r("br")])]),r("h5",{attrs:{id:"删除链表的倒数第n个结点q19中等"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#删除链表的倒数第n个结点q19中等"}},[e._v("#")]),e._v(" 删除链表的倒数第N个结点q19中等")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：删除第N个节点。"),r("br"),e._v("题解要点：1、删除当前节点。")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("cur.next = cur.next.next;//删除第N个节点\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br")])]),r("h5",{attrs:{id:"删除排序链表中的重复元素iiq82中等"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#删除排序链表中的重复元素iiq82中等"}},[e._v("#")]),e._v(" 删除排序链表中的重复元素IIq82中等")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("82. 删除排序链表中的重复元素 II - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：连续删除节点。"),r("br"),e._v("题解要点：1、删除“有序链表”的重复元素，说明重复元素是连续的。")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("if (cur.next.val == cur.next.next.val) {\n    //连续删除重复元素\n    int x = cur.next.val;\n    while (cur.next != null && cur.next.val == x) {\n        cur.next = cur.next.next;\n    }\n}\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br"),r("span",{staticClass:"line-number"},[e._v("6")]),r("br"),r("span",{staticClass:"line-number"},[e._v("7")]),r("br")])]),r("h5",{attrs:{id:"旋转链表q61中等"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#旋转链表q61中等"}},[e._v("#")]),e._v(" 旋转链表q61中等")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/rotate-list/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("61. 旋转链表 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：旋转链表。"),r("br"),e._v("题解要点："),r("br"),e._v("1、旋转链表指把链表看成一个环。旋转一次，所有节点右移一位。"),r("br"),e._v("2、遍历拿到尾节点，连上头节点，形成环。"),r("br"),e._v("3、形成环后，遍历拿到新的头节点。"),r("br"),e._v("4、遍历拿到新的尾节点，断开环。")]),e._v(" "),r("h5",{attrs:{id:"分隔链表q86中等"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分隔链表q86中等"}},[e._v("#")]),e._v(" 分隔链表q86中等")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/partition-list/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("86. 分隔链表 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：链表重组。"),r("br"),e._v("题解要点：遍历链表，找出x的大小值。")]),e._v(" "),r("h5",{attrs:{id:"lru-最近最少使用-缓存q146中等"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#lru-最近最少使用-缓存q146中等"}},[e._v("#")]),e._v(" LRU（最近最少使用）缓存q146中等")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/lru-cache/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("146. LRU 缓存 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：热留存（排头），冷淘汰（删尾）。"),r("br"),e._v("题解要点："),r("br"),e._v("1、每次使用get后，要移动到链表头。"),r("br"),e._v("2、每次使用put后，要添加到链表头。如果链表满，还要删除链表尾。")]),e._v(" "),r("h4",{attrs:{id:"二叉树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二叉树"}},[e._v("#")]),e._v(" 二叉树")]),e._v(" "),r("h5",{attrs:{id:"二叉树的最大深度q104简单"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的最大深度q104简单"}},[e._v("#")]),e._v(" 二叉树的最大深度q104简单")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("104. 二叉树的最大深度 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：二叉树深度。"),r("br"),e._v("题解要点："),r("br"),e._v("1、根树深度=1+最大值(左子树深度,右子树深度)。"),r("br"),e._v("2、叶子树深度=0。"),r("br"),e._v("3、满足递归条件。")]),e._v(" "),r("h5",{attrs:{id:"相同的树q100简单"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#相同的树q100简单"}},[e._v("#")]),e._v(" 相同的树q100简单")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/same-tree/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("100. 相同的树 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：同时遍历两个树，比较。"),r("br"),e._v("题解要点：")]),e._v(" "),r("h6",{attrs:{id:"深度优先搜索-递归"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#深度优先搜索-递归"}},[e._v("#")]),e._v(" 深度优先搜索（递归）：")]),e._v(" "),r("p",[e._v("1、根树相同=左子树相同&右子树相同。"),r("br"),e._v("2、叶子树是否相同是明确的。"),r("br"),e._v("3、满足递归条件。")]),e._v(" "),r("h6",{attrs:{id:"广度优先搜索-迭代"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#广度优先搜索-迭代"}},[e._v("#")]),e._v(" 广度优先搜索（迭代）：")]),e._v(" "),r("p",[e._v("1、双队列（先进先出），横向顺序放入队列。"),r("br"),e._v("2、一一比较。")]),e._v(" "),r("h5",{attrs:{id:"翻转二叉树q226简单"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#翻转二叉树q226简单"}},[e._v("#")]),e._v(" 翻转二叉树q226简单")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/invert-binary-tree/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("226. 翻转二叉树 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：遍历树，翻转。"),r("br"),e._v("题解要点：")]),e._v(" "),r("h6",{attrs:{id:"深度优先搜索-递归-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#深度优先搜索-递归-2"}},[e._v("#")]),e._v(" 深度优先搜索（递归）：")]),e._v(" "),r("p",[e._v("1、子树翻转，则根树翻转。"),r("br"),e._v("2、子树翻转是明确的。"),r("br"),e._v("3、满足递归条件。")]),e._v(" "),r("h6",{attrs:{id:"广度优先搜索-迭代-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#广度优先搜索-迭代-2"}},[e._v("#")]),e._v(" 广度优先搜索（迭代）：")]),e._v(" "),r("p",[e._v("1、队列（先进先出），横向顺序放入队列"),r("br"),e._v("2、一一翻转。")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("TreeNode tmp = queue.poll();\nTreeNode left = tmp.left;\ntmp.left = tmp.right;\ntmp.right = left;\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br")])]),r("h5",{attrs:{id:"对称二叉树q101简单"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对称二叉树q101简单"}},[e._v("#")]),e._v(" 对称二叉树q101简单")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/symmetric-tree/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("101. 对称二叉树 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：同时遍历两个树，比较。"),r("br"),e._v("题解要点：")]),e._v(" "),r("h6",{attrs:{id:"深度优先搜索-递归-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#深度优先搜索-递归-3"}},[e._v("#")]),e._v(" 深度优先搜索（递归）：")]),e._v(" "),r("p",[e._v("1、子树相等，则根树相等。"),r("br"),e._v("2、子树是否相等是明确的。"),r("br"),e._v("3、满足递归条件。")]),e._v(" "),r("h6",{attrs:{id:"广度优先搜索-迭代-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#广度优先搜索-迭代-3"}},[e._v("#")]),e._v(" 广度优先搜索（迭代）：")]),e._v(" "),r("p",[e._v("1、队列（先进先出），横向顺序放入队列。"),r("br"),e._v("2、一一比较。")]),e._v(" "),r("h5",{attrs:{id:"从前序与中序遍历序列构造二叉树q105中等"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#从前序与中序遍历序列构造二叉树q105中等"}},[e._v("#")]),e._v(" 从前序与中序遍历序列构造二叉树q105中等")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("105. 从前序与中序遍历序列构造二叉树 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：前中序反推二叉树节点。"),r("br"),e._v("题解要点：")]),e._v(" "),r("h6",{attrs:{id:"特殊深度优先搜索-递归"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#特殊深度优先搜索-递归"}},[e._v("#")]),e._v(" 特殊深度优先搜索（递归）：")]),e._v(" "),r("p",[e._v("1、前序遍历，可得根节点。"),r("br"),e._v("2、根节点+中序遍历，可得左右子节点。")]),e._v(" "),r("blockquote",[r("p",[e._v("//这个“构建树方法”是，通过准确的拿到“前序遍历”的根节点位置与左右子节点位置构造出来的。"),r("br"),e._v("//所以找到“前序遍历”的根节点位置与左右子节点位置，就是题解。"),r("br"),e._v("//（解题时会发现，“前序遍历”的左右子树边界位置，难以确定。必须借助“中序遍历”根节点位置与左子树边界位置才能确定。）")])]),e._v(" "),r("h6",{attrs:{id:"广度优先搜索-迭代-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#广度优先搜索-迭代-4"}},[e._v("#")]),e._v(" 广度优先搜索（迭代）：")]),e._v(" "),r("p",[e._v("这个逻辑可读性差，忽略。")]),e._v(" "),r("blockquote",[r("p",[e._v("1、“前序遍历”中，[根节点,左子树,右子树]。\n2、“中序遍历”中，[左子树,根节点,右子树]。\n3、遍历“前序遍历”与“中序遍历”，把“前序遍历”压入栈中，\n4、如果"),r("code",[e._v("“前序遍历”栈顶")]),e._v("≠"),r("code",[e._v("“中序遍历”最左")]),e._v("说明没有来到"),r("code",[e._v("“前序遍历”的左子树")]),e._v("的左右节点边界。\n5、如果"),r("code",[e._v("“前序遍历”栈顶")]),e._v("="),r("code",[e._v("“中序遍历”最左")]),e._v("说明来到"),r("code",[e._v("“前序遍历”的左子树")]),e._v("的左右节点边界+1，即来到"),r("code",[e._v("“前序遍历”的左子树")]),e._v("的右节点。\n（注意：这里"),r("code",[e._v("“前序遍历”")]),e._v("弹栈与"),r("code",[e._v("“中序遍历”")]),e._v("右移一一比较，相当于"),r("code",[e._v("“前序遍历”左子树")]),e._v("与"),r("code",[e._v("“中序遍历”左子树")]),e._v("反方向一一比较，这样可以判断节点是"),r("code",[e._v("“前序遍历”左子树")]),e._v("中的左节点还是右节点。相同是左节点，不同是右节点。）\n6、手写这个逻辑较难。")])]),e._v(" "),r("p",[r("img",{attrs:{src:"https://jiq-picture.yuxing138.top/836c71f71e72b12214428a4aa5f80daf/1699278507845-ffeffee4-7e19-43b7-8264-70523ed05913.png#averageHue=%23f8f7f7&clientId=uad89c4f6-5007-4&from=paste&height=356&id=u0b2fb4e3&originHeight=1607&originWidth=1353&originalType=binary&ratio=2.5&rotation=0&showTitle=false&size=141139&status=done&style=none&taskId=u467a2c37-0651-4cc7-a93d-4f14c77c910&title=&width=300",alt:"image.png"}})]),e._v(" "),r("h5",{attrs:{id:"从中序与后序遍历序列构造二叉树q106中等"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#从中序与后序遍历序列构造二叉树q106中等"}},[e._v("#")]),e._v(" 从中序与后序遍历序列构造二叉树q106中等")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：中后序反推二叉树节点。"),r("br"),e._v("题解要点："),r("br"),e._v("同上。")]),e._v(" "),r("h5",{attrs:{id:"填充每个节点的下一个右侧节点指针iiq117中等"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#填充每个节点的下一个右侧节点指针iiq117中等"}},[e._v("#")]),e._v(" 填充每个节点的下一个右侧节点指针IIq117中等")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("117. 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：二叉树的每个节点新增一个水平指针next。"),r("br"),e._v("题解要点：")]),e._v(" "),r("h6",{attrs:{id:"广度优先搜索-迭代-5"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#广度优先搜索-迭代-5"}},[e._v("#")]),e._v(" 广度优先搜索（迭代）：")]),e._v(" "),r("p",[e._v("1、这个题的难点是“怎么一层层处理水平层的节点？”。"),r("br"),e._v("从第一层开始遍历树，把"),r("code",[e._v("水平层节点")]),e._v("放入队列中，并处理"),r("code",[e._v("next")]),e._v("指针。"),r("br"),e._v("2、“怎么确定是每一层的头节点、尾节点？”")]),e._v(" "),r("h5",{attrs:{id:"二叉树展开为链表q114中等"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二叉树展开为链表q114中等"}},[e._v("#")]),e._v(" 二叉树展开为链表q114中等")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("114. 二叉树展开为链表 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：二叉树重组。"),r("br"),e._v("题解要点：")]),e._v(" "),r("h6",{attrs:{id:"深度优先搜索-递归-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#深度优先搜索-递归-4"}},[e._v("#")]),e._v(" 深度优先搜索（递归）：")]),e._v(" "),r("p",[e._v("1、题中的二叉树是以"),r("code",[e._v("前序序列")]),e._v("的方式存放。"),r("br"),e._v("2、以"),r("code",[e._v("前序遍历")]),e._v("遍历树，同时放入"),r("code",[e._v("数组")]),e._v("中。"),r("br"),e._v("3、从"),r("code",[e._v("数组")]),e._v("取出节点，并更新左右指针，形成"),r("code",[e._v("链表（单边树）")]),e._v("。")]),e._v(" "),r("h5",{attrs:{id:"路径总和q112简单"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#路径总和q112简单"}},[e._v("#")]),e._v(" 路径总和q112简单")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/path-sum/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("112. 路径总和 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：统计二叉树根路径。"),r("br"),e._v("题解要点：")]),e._v(" "),r("h6",{attrs:{id:"广度优先搜索-迭代-6"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#广度优先搜索-迭代-6"}},[e._v("#")]),e._v(" 广度优先搜索（迭代）：")]),e._v(" "),r("p",[e._v("1、到达当前节点的路径总和=当前节点值+所有父节点值。")]),e._v(" "),r("h5",{attrs:{id:"求根节点到叶节点数字之和q129中等"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#求根节点到叶节点数字之和q129中等"}},[e._v("#")]),e._v(" 求根节点到叶节点数字之和q129中等")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("129. 求根节点到叶节点数字之和 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：统计二叉树根路径数字。"),r("br"),e._v("题解要点：")]),e._v(" "),r("h6",{attrs:{id:"深度优先搜索-递归-5"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#深度优先搜索-递归-5"}},[e._v("#")]),e._v(" 深度优先搜索（递归）：")]),e._v(" "),r("blockquote",[r("p",[e._v("深度优先搜索是很直观的做法。从根节点开始，遍历每个节点，如果遇到"),r("code",[e._v("叶子节点")]),e._v("，则将叶子节点对应的数字加到数字之和。如果当前节点"),r("code",[e._v("不是叶子节点")]),e._v("，则计算其子节点对应的数字，然后对子节点递归遍历。")])]),e._v(" "),r("p",[e._v("1、在深度优先遍历树的过程中，累加节点值。")]),e._v(" "),r("h6",{attrs:{id:"广度优先搜索-迭代-7"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#广度优先搜索-迭代-7"}},[e._v("#")]),e._v(" 广度优先搜索（迭代）：")]),e._v(" "),r("blockquote",[r("p",[e._v("1、使用广度优先搜索，需要维护两个队列，分别存储节点和节点对应的数字。\n2、初始时，将根节点和根节点的值分别加入两个队列。"),r("code",[e._v("每次从两个队列分别取出")]),e._v("一个节点和一个数字，进行如下操作：\n（1）如果当前节点是叶子节点，则将该节点对应的数字加到数字之和；\n（2）如果当前节点不是叶子节点，则获得当前节点的非空子节点，并根据当前节点对应的数字和子节点的值计算子节点对应的数字，然后将"),r("code",[e._v("子节点和子节点对应的数字")]),e._v("分别"),r("code",[e._v("加入两个队列")]),e._v("。\n（每次把左右节点放入队列，再从队列取出第一个，则取出的节点是水平优先的。）\n3、搜索结束后，即可得到所有叶子节点对应的数字之和。）")])]),e._v(" "),r("p",[e._v("1、在广度优先遍历树的过程中，通过“值队列”存放累加节点值。")]),e._v(" "),r("h5",{attrs:{id:"二叉树中的最大路径和q124困难"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二叉树中的最大路径和q124困难"}},[e._v("#")]),e._v(" 二叉树中的最大路径和q124困难")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("124. 二叉树中的最大路径和 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：统计二叉树路径。"),r("br"),e._v("题解要点：")]),e._v(" "),r("h6",{attrs:{id:"深度优先搜索-递归-6"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#深度优先搜索-递归-6"}},[e._v("#")]),e._v(" 深度优先搜索（递归）：")]),e._v(" "),r("p",[e._v("1、不能直接递归：当前节点的最大路径≠左右子节点的最大路径。"),r("br"),e._v("2、当前节点的最大路径="),r("code",[e._v("自己+当前节点到叶子节点最大值(左节点)+当前节点到叶子节点最大值(右节点)")]),e._v("。")]),e._v(" "),r("h5",{attrs:{id:"二叉搜索树迭代器q173中等"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二叉搜索树迭代器q173中等"}},[e._v("#")]),e._v(" 二叉搜索树迭代器q173中等")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/binary-search-tree-iterator/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("173. 二叉搜索树迭代器 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：遍历二叉树。"),r("br"),e._v("题解要点：")]),e._v(" "),r("h6",{attrs:{id:"深度优先搜索-递归-7"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#深度优先搜索-递归-7"}},[e._v("#")]),e._v(" 深度优先搜索（递归）：")]),e._v(" "),r("blockquote",[r("p",[e._v("直接对二叉搜索树做一次完全的递归遍历，获取"),r("code",[e._v("中序遍历")]),e._v("的全部结果并保存在数组中。随后，我们利用得到的数组本身来实现迭代器。")])]),e._v(" "),r("p",[e._v("1、题干要求输入"),r("code",[e._v("前序序列")]),e._v("输出"),r("code",[e._v("中序序列(升序序列)")]),e._v("。"),r("br"),e._v("2、所以，递归遍历二叉树时，"),r("code",[e._v("中序序列(升序序列)")]),e._v("放入数组。迭代器next取出时，为"),r("code",[e._v("中序遍历")]),e._v("。")]),e._v(" "),r("h6",{attrs:{id:"广度优先搜索-迭代-8"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#广度优先搜索-迭代-8"}},[e._v("#")]),e._v(" 广度优先搜索（迭代）：")]),e._v(" "),r("blockquote",[r("p",[e._v("除了递归的方法外，我们还可以利用栈这一数据结构，通过迭代的方式对二叉树做中序遍历。此时，我们无需预先计算出中序遍历的全部结果，只需要实时维护当前栈的情况即可。")])]),e._v(" "),r("p",[e._v("1、题干要求输入"),r("code",[e._v("前序序列")]),e._v("输出"),r("code",[e._v("中序序列(升序序列)")]),e._v("。"),r("br"),e._v("2、所以迭代器next时，先"),r("code",[e._v("中序序列(升序序列)")]),e._v("放入栈，再出栈，即为"),r("code",[e._v("中序遍历")]),e._v("。")]),e._v(" "),r("h5",{attrs:{id:"完全二叉树的节点个数q222简单"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#完全二叉树的节点个数q222简单"}},[e._v("#")]),e._v(" 完全二叉树的节点个数q222简单")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/count-complete-tree-nodes/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("222. 完全二叉树的节点个数 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：遍历二叉树。")]),e._v(" "),r("blockquote",[r("p",[e._v("完全二叉树：在完全二叉树中，除了"),r("code",[e._v("最底层节点可能没填满")]),e._v("外，其余"),r("code",[e._v("每层节点数都达到最大值")]),e._v("，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。")])]),e._v(" "),r("p",[e._v("题解要点：")]),e._v(" "),r("h6",{attrs:{id:"深度优先搜索-递归-8"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#深度优先搜索-递归-8"}},[e._v("#")]),e._v(" 深度优先搜索（递归）：")]),e._v(" "),r("p",[e._v("1、当前树的节点个数=自己一个+左右子树的节点个数。"),r("br"),e._v("2、子树的节点个数是明确的。"),r("br"),e._v("3、满足递归条件。")]),e._v(" "),r("h5",{attrs:{id:"二叉树的最近公共祖先q236中等"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二叉树的最近公共祖先q236中等"}},[e._v("#")]),e._v(" 二叉树的最近公共祖先q236中等")]),e._v(" "),r("p",[e._v("题目来源："),r("a",{attrs:{href:"https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/",target:"_blank",rel:"noopener noreferrer"}},[e._v("236. 二叉树的最近公共祖先 - 力扣（LeetCode）"),r("OutboundLink")],1),r("br"),e._v("题干：遍历二叉树。")]),e._v(" "),r("blockquote",[r("p",[e._v("公共祖先：在树中的节点p、q的共同祖先节点x（每个节点都是它自己的祖先）。\n最近公共祖先：节点x的深度尽可能大。节点p、q与节点x的距离尽可能小。")])]),e._v(" "),r("p",[e._v("题解要点：")]),e._v(" "),r("h6",{attrs:{id:"深度优先搜索-递归-9"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#深度优先搜索-递归-9"}},[e._v("#")]),e._v(" 深度优先搜索（递归）：")]),e._v(" "),r("p",[e._v("1、不能直接递归：当前节点是"),r("code",[e._v("p与q")]),e._v("的祖先≠左、右节点是"),r("code",[e._v("p与q")]),e._v("的祖先。"),r("br"),e._v("2、当前节点是"),r("code",[e._v("p或q")]),e._v("的祖先=左、右、自己节点是"),r("code",[e._v("p或q")]),e._v("其中1个。"),r("br"),e._v("3、在递归的过程中，记录最近公共祖先。（这个判断逻辑其实比较难想到。）")]),e._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("if (isLeft && isRight) {\n    ans = root;\n} else if (isSelf(root, p, q) && (isLeft || isRight)) {//自己是其中1个 && 左、右是其中1个\n    ans = root;\n}\n")])]),e._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[e._v("1")]),r("br"),r("span",{staticClass:"line-number"},[e._v("2")]),r("br"),r("span",{staticClass:"line-number"},[e._v("3")]),r("br"),r("span",{staticClass:"line-number"},[e._v("4")]),r("br"),r("span",{staticClass:"line-number"},[e._v("5")]),r("br")])]),r("h6",{attrs:{id:"存储父节点-递归"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#存储父节点-递归"}},[e._v("#")]),e._v(" 存储父节点（递归）：")]),e._v(" "),r("p",[e._v("1、每个节点只有一个父节点，递归遍历树把每个节点的父节点保存到哈希表。"),r("br"),e._v("2、迭代p的父节点，得到p的全部祖先节点。保存到哈希表。"),r("br"),e._v("3、得到p、q的全部祖先节点，得解。")])])}),[],!1,null,null,null);r.default=s.exports}}]);